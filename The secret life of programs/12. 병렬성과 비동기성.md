
# 병렬성과 비동기성
컴퓨터는 어떻게 한 번에 많은 일을 하는가

### 경합조건과 공유자원
1. 멀티태스킹 : 컴퓨터가 한 번에 둘 이상의 작업을 수행하는 것
  - 때로 처리 순서가 중요한데, 멀티태스킹의 이점을 잃지 않고 경합 조건을 해결하고 락을 사용하기는 어렵다.

2. 경합 조건 (race condition) : 2개 또는 그 이상의 프로그램이 같은 자원에 동시에 접근하고, 자원 사용 순서에 따라 결과가 달라지는 경우.
3. 메모리뿐만 아니라 FPGA, 프린터와 같은 I/O장치 모두 공유 자원이 될 수 있다.

### 프로세스와 스레드
1. 운영체제는 프로세스를 관리하며, 프로세스란 **사용자 공간(user space)에서 실행되는 프로그램**이다.
  - 멀티코어 시스템에서는 여러 프로그램이 병렬로 실행될 수 있다.
2. 경합 조건은 1) 여러 프로그램이 병렬로 실행되고 2) 병렬로 실행되는 프로그램이 자원을 공유해야 발생 가능하다
3. 프로세스가 자원을 공유하려면 어떤 방식으로든 서로 통신을 해야 한다. 이 때 통신은 여러 가지 형태로 일어날 수 있다. (프로그램에 코드 형태로 or 설정 정보 등)
4. 스레드 : 정적인 데이터와 힙을 공유하지만 자체적으로 스택을 갖는 프로그램의 일부분
  - 각 스레드는 자신이 CPU 레지스터를 완전히 소유한다고 가정
  - 한 스레드에서 다른 스레드로 실행이 넘어갈 때 스레드 스케줄러(thread scheduler)가 CPU 레지스터를 저장해야 함
  - 경량 프로세스(lightweight process)라고도 부름
  - 스레드를 사용하면 한 프로세스 안에서 경합 조건을 만들 수 있음
  - ex. 자바스크립트 이벤트 핸들러

### 락
1. 실제로 처리해야 하는 문제는 여러 작은 연산으로 이뤄진 작업을 어떻게 원자적(atomic)으로 만들 수 있을까 하는 문제임
  - '원자적' : 나눌 수 없고 인터럽트할 수 없음
  - keyword : 상호 배제(mutual exclusion) 매커니즘, 어드바이저리 락(adviosry lock)
2. 트랜잭션과 작업 크기
  - 각 연산은 실제로 양방향 통신
  - 트랜잭션 : 데이터베이스에서 온 것으로, 각 연산을 독립적으로 수행하는 대신 (원자적으로 실행해야 하는 일련의 연산을) 한 번에 묶어서 처리함.
  - 락이 걸린 작업의 크기(granularity)를 최소화해야 함
  - 아주 작은 부분만 잠그는 락 : 세밀하다(fine-grained)고 표현 / 더 큰 범위를 잠그는 락 : 성기다(coarse-grained)고 표현
3. 락 대기
  - spin : 락을 성공적으로 얻을 때까지 락 획득을 반복 시도
  - 소규모 환경에서 락을 등록(register)하고 통지(notify)받는 경우도 있음
  - 블로킹 : 시스템이 락을 할당할 수 있을 때까지 락을 요청한 프로그램을 일시중단시킴
  - 논블로킹 : 프로그램이 계속 실행되고 나중에 락을 얻었는지 여부를 통지받음
4. 교착 상태
  - 공유 자원과 이 자원을 함께 사용하는 프로세스(또는 스레드 등)가 여럿 있을 때, 다음의 4가지 조건을 동시 만족할 때만 발생
    - 상호 배제(mutual exclusion): 공유 자원을 함께 쓸 수 없어서 어느 한 프로세스가 독점적으로 사용해야만 함
    - 점유 대기(hold an wait): 프로세스들은 어느 자원을 점유한 상태에서 다른 자원을 요청
    - 비선점(no preemption): 프로세스가 할당받은 자원을 강제로 빼앗을 수 없음
    - 순환 대기(circular wait): 각 프로세스가 서로 순환적으로 다른 프로세스가 갖고 있는 자원을 요구
  - 교착상태의 해결
    - 자원을 상호배제하지 않고 언제든 공유 가능한 자원으로 만들기
    - 어느 자원을 점유한 다음, 다른 자원을 요구하지 않고 한꺼번에 자원 요구
    - 선점형으로 변경
    - 자원마다 우선순위를 부여해 모든 프로세스가 다 서로 정해진 순서대로만 자원을 요구
5. 단기 락 구현, 장기 락 구현

### 브라우저 자바스크립트
- 자바스크립트: 단일 스레드 프로그램. JS의 원래 목표는 더 빠르게 사용자 피드백을 제공하고 인터넷 피드백을 줄이는 것이었음.
- 자바스크립트로 인해 사용자가 입력을 잘못했을 때 서버까지 요청을 보내 결과가 돌아올 때까지 기다리지 않아도 된다는 의미
- 자바스크립트 구현 : 이벤트 루프(event loop) 모델 사용
- 프로그래머가 이벤트가 큐에 추가되는 순서를 제어할 수는 없음
- 처음 등장 시에는 비동기 통신을 언어 설계에 포함하지 않았으나, 1)DOM의 등장과 2)XHR(AJAX의 기반)의 등장으로 웹 페이지 복잡도가 크게 증가 > JS활용도 높아짐 > 필요성이 증대
  - DOM : 웹 페이지 중 일부만 변경 가능하게끔 바뀜
  - XHR(AJAX) : 기존의 페이지 로드 모델에서 벗어나 백그라운드에서 브라우저와 서버가 통신할 수 있게 됨
- 자바스크립트 인터프리터는 단일 스레드 모델을 제공하지만 내부에서는 멀티스레드를 활용

### 비동기 함수와 프로미스
- 콜백, POST 방식을 활용하는 것은 나쁘다 (왜?)
- **프로미스(promise)** 라는 구성 요소를 추가해 비동기 문제를 해결하고자 함
- 프로미스는 비동기 콜백 메커니즘을 언어 고유 기능으로 넣어서 라이브러리가 잘못 비동기 연산을 구현하지 못하게 한다.
- 프로미스는 편의 문법(syntactic sugar) 이기도 함

